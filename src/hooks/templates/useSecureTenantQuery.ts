/**
 * üîê TEMPLATE OBRIGAT√ìRIO PARA TODAS AS CONSULTAS MULTI-TENANT
 * 
 * Este hook garante que NUNCA haver√° vazamento de dados entre tenants
 * USO OBRIGAT√ìRIO em todas as p√°ginas que manipulam dados de tenant
 */

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/lib/supabase';
import { useMemo } from 'react';
import { useZustandTenant } from '@/hooks/useZustandTenant';
import type { SupabaseClient } from '@supabase/supabase-js';
import { throttledDebug, throttledTenantGuard } from '@/utils/logThrottle';
import { SecurityMiddleware } from '@/core/security/SecurityMiddleware';

/**
 * Hook seguro para consultas que SEMPRE inclui tenant_id
 * 
 * ‚ö†Ô∏è NUNCA fa√ßa consultas diretas ao Supabase sem usar este hook
 */
export function useSecureTenantQuery<T>(
  queryKey: string[],
  queryFn: (supabase: SupabaseClient, tenantId: string) => Promise<T>,
  options?: {
    enabled?: boolean;
    staleTime?: number;
    refetchOnWindowFocus?: boolean;
  }
) {
  const { currentTenant, userRole } = useTenantAccessGuard();
  
  // üö® VALIDA√á√ÉO CR√çTICA: Tenant deve estar definido
  const isValidTenant = currentTenant?.id && currentTenant?.active;
  
  // üîç DEBUG: Log do estado do tenant (com throttling otimizado)
  throttledDebug('useSecureTenantQuery_state', `useSecureTenantQuery - Tenant: ${currentTenant?.name}`, {
    tenantId: currentTenant?.id,
    tenantName: currentTenant?.name,
    isValidTenant,
    queryKeyLength: queryKey.length,
    enabled: isValidTenant && (options?.enabled !== false)
  });
  
  return useQuery({
    // üîë CHAVE SEMPRE INCLUI TENANT_ID
    queryKey: [...queryKey, currentTenant?.id],
    
    queryFn: async () => {
      // üõ°Ô∏è VALIDA√á√ÉO DUPLA DE SEGURAN√áA
      if (!currentTenant?.id) {
        throw new Error('‚ùå ERRO CR√çTICO: Tenant n√£o definido - poss√≠vel vazamento de dados!');
      }
      
      if (!currentTenant.active) {
        throw new Error('‚ùå ERRO: Tenant inativo - acesso negado');
      }
      
      // ‚úÖ Executar query com tenant_id garantido
      const result = await queryFn(supabase, currentTenant.id);
      return result;
    },
    
    // üîí S√ì EXECUTA SE TENANT V√ÅLIDO
    enabled: isValidTenant && (options?.enabled !== false),
    
    staleTime: options?.staleTime || 10 * 60 * 1000, // 10 minutos
    gcTime: 15 * 60 * 1000, // 15 minutos (substitui cacheTime)
    refetchOnWindowFocus: options?.refetchOnWindowFocus ?? false,
    refetchOnMount: false,
    
    // üö® TRATAMENTO DE ERRO CR√çTICO - Removido onError (deprecated no React Query v5)
  });
}

/**
 * Hook seguro para muta√ß√µes que SEMPRE inclui tenant_id
 */
export function useSecureTenantMutation<TData, TVariables>(
  mutationFn: (supabase: SupabaseClient, tenantId: string, variables: TVariables) => Promise<TData>,
  options?: {
    onSuccess?: (data: TData) => void;
    onError?: (error: Error) => void;
    invalidateQueries?: string[];
  }
) {
  const { currentTenant } = useTenantAccessGuard();
  const queryClient = useQueryClient();
  
  // AIDEV-NOTE: Inst√¢ncia do SecurityMiddleware para configurar contexto de tenant
  const securityMiddleware = new SecurityMiddleware({ supabaseClient: supabase });

  return useMutation({
    mutationFn: async (variables: TVariables) => {
      // üõ°Ô∏è VALIDA√á√ÉO CR√çTICA ANTES DE QUALQUER MUTA√á√ÉO
      if (!currentTenant?.id) {
        throw new Error('‚ùå ERRO CR√çTICO: Tentativa de muta√ß√£o sem tenant definido!');
      }
      
      if (!currentTenant.active) {
        throw new Error('‚ùå ERRO: Tentativa de muta√ß√£o em tenant inativo');
      }
      
      throttledTenantGuard('mutation_audit', `‚úèÔ∏è [AUDIT] Muta√ß√£o para tenant: ${currentTenant.name} (${currentTenant.id})`);
      
      // AIDEV-NOTE: Configurar contexto de tenant no banco ANTES da opera√ß√£o
      const contextApplied = await securityMiddleware.applyTenantContext(currentTenant.id);
      
      if (!contextApplied) {
        throw new Error('‚ùå ERRO CR√çTICO: Falha ao configurar contexto de tenant no banco de dados');
      }
      
      try {
        // Executar a muta√ß√£o com o contexto configurado
        const result = await mutationFn(supabase, currentTenant.id, variables);
        return result;
      } finally {
        // AIDEV-NOTE: Limpar contexto ap√≥s a opera√ß√£o para seguran√ßa
        await securityMiddleware.clearTenantContext();
      }
    },
    
    onSuccess: (data) => {
      // üîÑ INVALIDAR CACHE ESPEC√çFICO DO TENANT
      if (options?.invalidateQueries) {
        options.invalidateQueries.forEach(queryKey => {
          queryClient.invalidateQueries({ 
            queryKey: [queryKey, currentTenant?.id] 
          });
        });
      }
      
      options?.onSuccess?.(data);
    },
    
    onError: (error: Error) => {
      throttledTenantGuard('mutation_error', 'üö® [SECURITY] Erro em muta√ß√£o multi-tenant:', {
        error: error.message,
        tenant: currentTenant?.id
      });
      
      options?.onError?.(error);
    }
  });
}

/**
 * üîç Hook para valida√ß√£o de acesso a dados espec√≠ficos
 * Use antes de renderizar componentes sens√≠veis
 */
export function useTenantAccessGuard(options?: { 
  requireTenant?: boolean; 
  requiredRole?: string; 
} | string) {
  // Suporte para compatibilidade com par√¢metro string (requiredRole)
  const { requireTenant = true, requiredRole } = typeof options === 'string' 
    ? { requireTenant: true, requiredRole: options }
    : (options || {});
  // Importa√ß√£o direta do hook Zustand
  const { currentTenant, userRole } = useZustandTenant();
  
  // üîç DEBUG: Log detalhado do tenant access guard
  throttledDebug('tenant_access_guard', `üîç [TENANT ACCESS GUARD] Verificando acesso:`, {
    currentTenant: currentTenant ? {
      id: currentTenant.id,
      name: currentTenant.name,
      slug: currentTenant.slug,
      active: currentTenant.active
    } : null,
    userRole,
    requiredRole,
    hasCurrentTenant: !!currentTenant?.id,
    isTenantActive: currentTenant?.active,
    roleMatch: !requiredRole || userRole === requiredRole
  });
  
  const hasAccess = useMemo(() => {
    // Se n√£o requer tenant, liberar acesso (para portal admin)
    if (!requireTenant) {
      throttledTenantGuard('access_granted_no_tenant', `‚úÖ [ACCESS GRANTED] Acesso liberado (tenant n√£o requerido)`);
      return true;
    }
    
    if (!currentTenant?.id) {
      throttledTenantGuard('access_denied_no_tenant', `üö® [ACCESS DENIED] Tenant n√£o definido`);
      return false;
    }
    if (!currentTenant?.active) {
      throttledTenantGuard('access_denied_inactive', `Tenant inativo: ${currentTenant.name}`);
      return false;
    }
    if (requiredRole && userRole !== requiredRole) {
      throttledTenantGuard('access_denied_role', `Permiss√£o insuficiente: required=${requiredRole}, user=${userRole}`);
      return false;
    }
    throttledTenantGuard('access_granted', `Acesso liberado para tenant: ${currentTenant.name}`);
    return true;
  }, [currentTenant?.id, currentTenant?.active, userRole, requiredRole, requireTenant]);
  
  const accessError = useMemo(() => {
    if (!requireTenant) return null;
    if (!currentTenant?.id) return 'Tenant n√£o definido';
    if (!currentTenant.active) return 'Tenant inativo';
    if (requiredRole && userRole !== requiredRole) return 'Permiss√£o insuficiente';
    return null;
  }, [currentTenant?.id, currentTenant?.active, userRole, requiredRole, requireTenant]);
  
  return { hasAccess, accessError, currentTenant, userRole };
}
