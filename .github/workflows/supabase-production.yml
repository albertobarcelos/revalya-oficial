name: Deploy Supabase - Production

on:
  push:
    branches:
      - main
    paths:
      - 'supabase/**'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    name: Deploy automÃ¡tico para ProduÃ§Ã£o
    environment: production  # Requer aprovaÃ§Ã£o manual se configurado

    env:
      SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      SUPABASE_PROJECT_ID: ${{ secrets.PRODUCTION_PROJECT_ID }}

    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # NecessÃ¡rio para detectar mudanÃ§as

      - name: Configurar Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Autenticar no Supabase
        run: |
          supabase login --token "$SUPABASE_ACCESS_TOKEN"

      - name: Linkar ao projeto Production
        run: supabase link --project-ref $SUPABASE_PROJECT_ID

      - name: Detectar mudanÃ§as nas migrations (apenas mudanÃ§as de develop)
        id: detect-migrations
        run: |
          # Se for merge de develop para main, detectar apenas mudanÃ§as desde develop
          if [ "${{ github.event_name }}" == "push" ]; then
            # Tentar encontrar o commit anterior (antes do merge)
            PREV_COMMIT="${{ github.event.before }}"
            if [ -z "$PREV_COMMIT" ] || [ "$PREV_COMMIT" == "0000000000000000000000000000000000000000" ]; then
              # Se nÃ£o conseguir, verificar se hÃ¡ mudanÃ§as em migrations
              if git diff --name-only HEAD~1 HEAD | grep -q '^supabase/migrations/'; then
                echo "has_migrations=true" >> $GITHUB_OUTPUT
                echo "âœ… Novas migrations detectadas"
              else
                echo "has_migrations=false" >> $GITHUB_OUTPUT
                echo "â„¹ï¸ Nenhuma migration nova"
              fi
            else
              if git diff --name-only $PREV_COMMIT ${{ github.sha }} | grep -q '^supabase/migrations/'; then
                echo "has_migrations=true" >> $GITHUB_OUTPUT
                echo "âœ… Novas migrations detectadas"
              else
                echo "has_migrations=false" >> $GITHUB_OUTPUT
                echo "â„¹ï¸ Nenhuma migration nova"
              fi
            fi
          else
            # workflow_dispatch - aplicar todas as migrations pendentes
            echo "has_migrations=true" >> $GITHUB_OUTPUT
            echo "âœ… Deploy manual - aplicando todas as migrations"
          fi

      - name: Detectar mudanÃ§as nas Edge Functions (apenas mudanÃ§as de develop)
        id: detect-functions
        run: |
          # Se for merge de develop para main, detectar apenas mudanÃ§as desde develop
          if [ "${{ github.event_name }}" == "push" ]; then
            PREV_COMMIT="${{ github.event.before }}"
            if [ -z "$PREV_COMMIT" ] || [ "$PREV_COMMIT" == "0000000000000000000000000000000000000000" ]; then
              if git diff --name-only HEAD~1 HEAD | grep -q '^supabase/functions/'; then
                echo "has_functions=true" >> $GITHUB_OUTPUT
                echo "âœ… MudanÃ§as nas Edge Functions detectadas"
              else
                echo "has_functions=false" >> $GITHUB_OUTPUT
                echo "â„¹ï¸ Nenhuma mudanÃ§a nas Edge Functions"
              fi
            else
              if git diff --name-only $PREV_COMMIT ${{ github.sha }} | grep -q '^supabase/functions/'; then
                echo "has_functions=true" >> $GITHUB_OUTPUT
                echo "âœ… MudanÃ§as nas Edge Functions detectadas"
              else
                echo "has_functions=false" >> $GITHUB_OUTPUT
                echo "â„¹ï¸ Nenhuma mudanÃ§a nas Edge Functions"
              fi
            fi
          else
            # workflow_dispatch - deployar todas as functions
            echo "has_functions=true" >> $GITHUB_OUTPUT
            echo "âœ… Deploy manual - deployando todas as Edge Functions"
          fi

      - name: Reparar histÃ³rico de migrations (se necessÃ¡rio)
        if: steps.detect-migrations.outputs.has_migrations == 'true'
        continue-on-error: true
        run: |
          echo "ðŸ”§ Verificando histÃ³rico de migrations..."
          # Tenta fazer repair das migrations que estÃ£o no banco mas nÃ£o no repositÃ³rio
          # Isso marca migrations antigas como "reverted" para permitir aplicar novas
          # As migrations listadas sÃ£o as que o erro mencionou como faltando no repositÃ³rio
          if supabase migration repair --status reverted 20240101000000 20250127 20251125 20251126 20251127 20251128 20251212 20251213 20251220040909 2>&1; then
            echo "âœ… HistÃ³rico de migrations reparado"
          else
            echo "â„¹ï¸ Repair nÃ£o necessÃ¡rio ou migrations jÃ¡ foram reparadas"
          fi

      - name: Marcar migrations jÃ¡ aplicadas no histÃ³rico
        if: steps.detect-migrations.outputs.has_migrations == 'true'
        continue-on-error: true
        run: |
          echo "ðŸ” Verificando migrations que jÃ¡ foram aplicadas..."
          # Marca migrations grandes que provavelmente jÃ¡ foram aplicadas como aplicadas no histÃ³rico
          # Isso evita tentar aplicÃ¡-las novamente
          supabase migration repair --status applied 20251218191500 20251219185127 2>/dev/null || echo "â„¹ï¸ Migrations jÃ¡ marcadas ou nÃ£o encontradas"

      - name: Aplicar migraÃ§Ãµes (apenas mudanÃ§as de develop)
        if: steps.detect-migrations.outputs.has_migrations == 'true'
        run: |
          echo "ðŸš€ Aplicando migrations na produÃ§Ã£o..."
          echo "âš ï¸  ATENÃ‡ÃƒO: Isso irÃ¡ modificar o banco de dados de produÃ§Ã£o!"
          # Usa --yes para aceitar automaticamente
          # Usa --include-all para incluir migrations nÃ£o rastreadas
          # O repair anterior jÃ¡ marcou migrations antigas como reverted
          # As migrations grandes jÃ¡ foram marcadas como aplicadas no passo anterior
          supabase db push --include-all --yes

      - name: Deploy Edge Functions (apenas mudanÃ§as de develop)
        if: steps.detect-functions.outputs.has_functions == 'true'
        run: |
          echo "ðŸš€ Fazendo deploy das Edge Functions na produÃ§Ã£o..."
          supabase functions deploy

      - name: Deploy todas as Edge Functions (se migrations foram aplicadas)
        if: steps.detect-functions.outputs.has_functions == 'false' && steps.detect-migrations.outputs.has_migrations == 'true'
        run: |
          echo "ðŸš€ Fazendo deploy de todas as Edge Functions (apÃ³s migrations)..."
          supabase functions deploy

      - name: Resumo do deploy
        run: |
          echo "## ðŸš€ Deploy ProduÃ§Ã£o ConcluÃ­do" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Projeto:** ProduÃ§Ã£o (main)" >> $GITHUB_STEP_SUMMARY
          echo "**Branch Git:** main" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Autor:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.detect-migrations.outputs.has_migrations }}" == "true" ]; then
            echo "âœ… Migrations aplicadas" >> $GITHUB_STEP_SUMMARY
          else
            echo "â„¹ï¸ Nenhuma migration nova para aplicar" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ steps.detect-functions.outputs.has_functions }}" == "true" ]; then
            echo "âœ… Edge Functions deployadas" >> $GITHUB_STEP_SUMMARY
          else
            echo "â„¹ï¸ Nenhuma mudanÃ§a nas Edge Functions" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Dashboard:** https://supabase.com/dashboard/project/${{ secrets.PRODUCTION_PROJECT_ID }}" >> $GITHUB_STEP_SUMMARY
