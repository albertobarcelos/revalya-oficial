# PRD - Refatoração ReconciliationTable.tsx

## 📋 Visão Geral

**Objetivo**: Refatorar o componente `ReconciliationTable.tsx` (821 linhas) em componentes menores e mais gerenciáveis, mantendo 100% da funcionalidade e UI existentes.

**Status**: Planejamento Completo ✅  
**Prioridade**: Média  
**Estimativa**: 8-12 horas de desenvolvimento  

---

## 🎯 Objetivos Específicos

### Objetivos Primários
- ✅ Melhorar a manutenibilidade do código
- ✅ Facilitar testes unitários
- ✅ Reduzir complexidade cognitiva
- ✅ Seguir princípios de responsabilidade única
- ✅ Manter performance otimizada

### Objetivos Secundários
- ✅ Facilitar reutilização de componentes
- ✅ Melhorar legibilidade do código
- ✅ Preparar base para futuras funcionalidades

---

## 📊 Análise Atual

### Métricas do Componente Atual
- **Linhas de código**: 821 linhas
- **Responsabilidades**: 7+ diferentes
- **Complexidade**: Alta
- **Testabilidade**: Baixa
- **Reutilização**: Limitada

### Componentes Identificados para Extração
1. **TableHeader** (Cabeçalho da tabela)
2. **TableRow** (Linha individual da tabela)
3. **ActionButtons** (Botões de ação)
4. **StatusBadge** (Badge de status)
5. **ValueCell** (Célula de valores monetários)
6. **SelectionCheckbox** (Checkbox de seleção)
7. **PaginationControls** (Controles de paginação)

---

## 🏗️ Arquitetura Proposta

### Estrutura de Arquivos
```
src/components/reconciliation/
├── ReconciliationTable.tsx (componente principal - reduzido)
├── parts/
│   ├── TableHeader.tsx
│   ├── TableRow.tsx
│   ├── ActionButtons.tsx
│   ├── StatusBadge.tsx
│   ├── ValueCell.tsx
│   ├── SelectionCheckbox.tsx
│   └── PaginationControls.tsx
└── types/
    └── table-parts.ts (tipos específicos)
```

### Hierarquia de Componentes
```
ReconciliationTable
├── TableHeader
│   └── SelectionCheckbox (header)
├── TableRow (para cada movimento)
│   ├── SelectionCheckbox
│   ├── StatusBadge
│   ├── ValueCell (múltiplas)
│   └── ActionButtons
└── PaginationControls
```

---

## 🔧 Especificações Técnicas

### 1. TableHeader Component
```typescript
interface TableHeaderProps {
  hasSelection: boolean;
  selectedCount: number;
  totalCount: number;
  onSelectAll: (selected: boolean) => void;
  allSelected: boolean;
  partiallySelected: boolean;
}
```

**Responsabilidades**:
- Renderizar cabeçalho da tabela
- Gerenciar seleção múltipla (select all)
- Exibir contador de selecionados

### 2. TableRow Component
```typescript
interface TableRowProps {
  movement: ImportedMovement;
  isSelected: boolean;
  hasSelection: boolean;
  onSelect: (id: string, selected: boolean) => void;
  onAction: (action: ReconciliationAction, movement: ImportedMovement) => void;
}
```

**Responsabilidades**:
- Renderizar linha individual
- Gerenciar seleção individual
- Coordenar sub-componentes

### 3. ActionButtons Component
```typescript
interface ActionButtonsProps {
  movement: ImportedMovement;
  onAction: (action: ReconciliationAction, movement: ImportedMovement) => void;
}
```

**Responsabilidades**:
- Renderizar botões de ação
- Determinar ações disponíveis
- Executar callbacks de ação

### 4. StatusBadge Component
```typescript
interface StatusBadgeProps {
  status: ReconciliationStatus;
  paymentStatus?: PaymentStatus;
  className?: string;
}
```

**Responsabilidades**:
- Renderizar badge de status
- Aplicar cores e estilos corretos
- Suportar diferentes tipos de status

### 5. ValueCell Component
```typescript
interface ValueCellProps {
  value: number;
  type: 'currency' | 'percentage';
  className?: string;
  highlight?: boolean;
}
```

**Responsabilidades**:
- Formatar valores monetários
- Aplicar formatação de porcentagem
- Destacar valores quando necessário

### 6. SelectionCheckbox Component
```typescript
interface SelectionCheckboxProps {
  checked: boolean;
  indeterminate?: boolean;
  onChange: (checked: boolean) => void;
  disabled?: boolean;
}
```

**Responsabilidades**:
- Renderizar checkbox customizado
- Suportar estado indeterminado
- Gerenciar interações

### 7. PaginationControls Component
```typescript
interface PaginationControlsProps {
  pagination: {
    page: number;
    limit: number;
    total: number;
    onPageChange: (page: number) => void;
    onLimitChange: (limit: number) => void;
  };
}
```

**Responsabilidades**:
- Renderizar controles de paginação
- Gerenciar mudanças de página
- Controlar itens por página

---

## 📋 Plano de Execução

### Fase 1: Preparação (1-2h)
1. ✅ Criar estrutura de pastas `parts/`
2. ✅ Definir interfaces TypeScript
3. ✅ Configurar exports no `index.ts`

### Fase 2: Extração Sequencial (4-6h)
1. **StatusBadge** (mais simples, sem estado)
2. **ValueCell** (formatação, sem estado)
3. **SelectionCheckbox** (interação simples)
4. **ActionButtons** (lógica condicional)
5. **PaginationControls** (estado complexo)
6. **TableHeader** (coordenação)
7. **TableRow** (integração)

### Fase 3: Integração (2-3h)
1. ✅ Atualizar `ReconciliationTable.tsx`
2. ✅ Remover código duplicado
3. ✅ Ajustar imports e exports

### Fase 4: Validação (1-2h)
1. ✅ Testes de funcionalidade
2. ✅ Verificação de UI
3. ✅ Performance check
4. ✅ Lint e type-check

---

## ✅ Critérios de Aceitação

### Funcionalidade
- [ ] Todas as funcionalidades existentes mantidas
- [ ] Seleção múltipla funcionando
- [ ] Ações de reconciliação funcionando
- [ ] Paginação funcionando
- [ ] Filtros funcionando
- [ ] Modais funcionando

### Qualidade de Código
- [ ] Componentes com responsabilidade única
- [ ] Interfaces TypeScript bem definidas
- [ ] Props tipadas corretamente
- [ ] Sem código duplicado
- [ ] AIDEV-NOTEs adicionados

### Performance
- [ ] Sem regressão de performance
- [ ] Memoização adequada
- [ ] Re-renders otimizados

### UI/UX
- [ ] Interface idêntica à atual
- [ ] Animações preservadas
- [ ] Responsividade mantida
- [ ] Acessibilidade preservada

---

## 🚨 Riscos e Mitigações

### Riscos Identificados
1. **Quebra de funcionalidade**
   - *Mitigação*: Testes extensivos após cada extração
   
2. **Regressão de performance**
   - *Mitigação*: Profiling antes e depois
   
3. **Inconsistência de tipos**
   - *Mitigação*: TypeScript strict mode
   
4. **Perda de contexto**
   - *Mitigação*: AIDEV-NOTEs detalhados

### Plano de Rollback
- Manter branch de backup
- Commits atômicos por componente
- Possibilidade de reverter individualmente

---

## 📈 Benefícios Esperados

### Imediatos
- ✅ Código mais legível e organizizado
- ✅ Facilidade para debugging
- ✅ Testes unitários mais simples

### Médio Prazo
- ✅ Desenvolvimento mais rápido de features
- ✅ Menor chance de bugs
- ✅ Onboarding mais fácil para novos devs

### Longo Prazo
- ✅ Reutilização de componentes
- ✅ Manutenção mais eficiente
- ✅ Base sólida para expansões

---

## 🔍 Métricas de Sucesso

### Quantitativas
- Redução de 821 → ~400 linhas no arquivo principal
- 7 novos componentes especializados
- 0 regressões funcionais
- 100% cobertura de tipos TypeScript

### Qualitativas
- Melhoria na legibilidade (avaliação da equipe)
- Facilidade de manutenção (tempo para implementar mudanças)
- Satisfação do desenvolvedor

---

## 📝 Notas de Implementação

### Padrões a Seguir
- Usar `memo()` para componentes puros
- Implementar `useCallback()` para funções passadas como props
- Manter consistência com design system Shadcn/UI
- Seguir convenções de nomenclatura do projeto

### AIDEV-NOTEs Obrigatórios
```typescript
// AIDEV-NOTE: Componente extraído de ReconciliationTable para melhor organização
// Responsabilidade: [descrever responsabilidade específica]
// Props: [listar props principais e seus propósitos]
// Estado: [descrever se tem estado interno ou é stateless]
```

---

## 🎯 Próximos Passos

1. **Aprovação do PRD** ✅
2. **Início da implementação** (Fase 1)
3. **Reviews incrementais** (após cada componente)
4. **Testes de integração** (Fase 4)
5. **Deploy e monitoramento**

---

**Documento criado em**: [Data atual]  
**Responsável**: Barcelitos AI Assistant  
**Revisão**: Pendente  
**Aprovação**: Pendente  

---

*Este PRD segue as melhores práticas de documentação técnica e serve como guia completo para a refatoração do ReconciliationTable.tsx, garantindo que todos os aspectos técnicos, funcionais e de qualidade sejam considerados durante a implementação.*